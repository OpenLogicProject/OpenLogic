% Part: turing-machines 
% Chapter: machines-computations 
% Section: introduction

\documentclass[../../include/open-logic-section]{subfiles}

\begin{document}

\olfileid{tur}{mac}{int} 
\olsection{Introduction}
\begin{explain}
 Even though the term ``Turing machine'' evokes the image of
a physical machine with moving parts, strictly speaking a Turing machine is
a purely mathematical construct. It is perhaps best to think of a Turing
machine as a program for a special kind of imaginary mechanism. This
mechanism consists of a \emph{tape} and a \emph{read-write head}. In our
version of Turing machines, the tape is infinite in one direction (to the
right), and it is divided into \emph{squares}, each of which may contain a
symbol from a finite \emph{alphabet}. Such alphabets can contain any number
of different symbols, but we will mainly make do with three: $\TMendtape$,
$\TMblank$, and $\TMstroke$. When the mechanism is started, the tape is
empty (i.e., each square contains the symbol $\TMblank$) except for the
leftmost square, which contains $\TMendtape$, and a finite number of
squares which contain the \emph{input}. At any time, the mechanism is in
one of a finite number of \emph{states}. At the outset, the head scans the
leftmost square and in a specified \emph{initial state}. At each step of
the mechanism's run, the content of the square currently scanned together
with the state the mechanism is in and the Turing machine program determine
what happens next. The Turing machine program consists of a list of
5-tuples $\langle q_i, \sigma, q_j, \sigma', D\rangle$. Whenever the
mechanism is in state $q_i$ and reads symbol $\sigma$, it replaces the
symbol on the current square with $\sigma'$, the head moves left, right, or
stays put according to whether $D$ is $\TMleft$, $\TMright$, or $\TMstay$,
and the mechanism goes into state~$q_j$. We say that the machine halts when
it encounters some state, ~$q_n$, and symbol, $\sigma$ such that there is
no instruction beginning $\langle q_n, \sigma\rangle$. In other words, the
machine has no instruction to carry out, and at that point, it ceases
operation. Halting is sometimes represented by a specific halt state~$h$.
This will be demonstrated in more detail later on.

Although it is possible to represent Turing machines using only sets of 
instructions, it is useful to have a visual representation of the
machines. Such visual, or diagrammatic, representations of Turing
machines are called \emph{state diagrams}. The diagrams are composed of
state cells connected by arrows. Unsurprisingly, the state cells represent the
states of the machine. Each arrow represents an instruction that can be
carried out from that state. The instruction is written above each arrow.
For example, the instruction $\TMblank :\TMstroke :\TMright$ on an arrow
leading from state $q_0$ to state $q_1$ can be read as \emph{if reading a blank in
state $q_0$, write a stroke, move right, and go to state $q_1$}. This is
equivalent to the instruction $\tuple{q_0, \TMblank, q_1, \TMstroke, 
\TMright}$.

Alan Turing invented Turing machines in 1936. While his interest at the
time was the decidability of first-order logic, the paper has been
described as a definitive paper on the foundations of computer design
(Copeland 1993, 10). Notice that this was a full five years before the
first working general purpose computer was built in 1941 (by the German
Konrad Zuse in his parents living room), seven years before Turing and his
colleagues at Bletchley Park built the code-breaking Colossus (1943), nine
years before the American ENIAC (1945), twelve years before the first
British general purpose computer the Manchester Mark I was built in
Manchester (1948) and thirteen years before the Americans first tested the
BINAC (1949). The Manchester Mark I has the distinction of being the first
stored-program computer - previous machines had to be rewired by hand for
each new task. \end{explain}


\end{document}
