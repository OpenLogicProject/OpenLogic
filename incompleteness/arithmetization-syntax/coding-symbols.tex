% Part: incompleteness
% Chapter: arithmetization-syntax
% Section: coding-symbols

\documentclass[../../include/open-logic-section]{subfiles}

\begin{document}

\olfileid{inc}{art}{cod}
\olsection{Coding Symbols}

The basic language~$\Lang L$ of first order logic makes use of the symbols
\[
\lnot, \lor, \land, \lif, \lforall, \lexists, \eq, (, )
\]
together with !!{enumerable} sets of variables and !!{constant}s, and
!!{enumerable} sets of !!{function}s and !!{predicate}s of arbitrary
arity.  We can assign \emph{codes} to each of these symbols in such a
way that every symbol is assigned a unique number as its code, and no
two different symbols are assigned the same number.  We know that this
is possible since the set of all symbols is !!{enumerable} and so
there is a !!{bijection} between it and the set of natural numbers.
But we want to make sure that we can recover the symbol (as well as
some information about it, e.g., the arity of a !!{function}) from its
code in a computable way.  There are many possible ways of doing this,
of course.  Here is one such way, which uses primitive recursive
functions.  (Recall that $\tuple{n_0, \dots, n_k}$ is the number
coding the sequence of numbers $n_0$, \dots, $n_k$.)

\begin{defn}
If $s$ is a symbol of~$\Lang L$, let the \emph{symbol code}~$\scode s$ be
defined as follows:
\begin{enumerate}
\item If $s$ is among the logical symbols, $\scode s$ is given by the
  following table:
\[
\begin{array}{cccccccccc}
\lnot & \lor & \land & \lif & \lforall & \lexists & \eq & ( & ) & ,\\
\tuple{0, 0} & \tuple{0, 1} & \tuple{0, 2} & \tuple{0, 3} & 
\tuple{0, 4} & \tuple{0, 5} & \tuple{0, 6} & \tuple{0, 7} &
\tuple{0, 8} & \tuple{0, 9} 
\end{array}
\]
\item If $s$ is the $i$-th variable $\Obj x_i$, then $\scode s = \tuple{1, i}$.
\item If $s$ is the $i$-th $n$-ary !!{constant}~$\Obj c_i^n$, then
  $\scode s = \tuple{2, n, i}$.
\item If $s$ is the $i$-th $n$-ary !!{function}~$\Obj f_i^n$, then
  $\scode s = \tuple{3, n, i}$.
\item If $s$ is the $i$-th $n$-ary !!{predicate}~$\Obj P_i^n$, then
  $\scode s = \tuple{4, n, i}$.
\end{enumerate}
\end{defn}

\begin{prop}
The following relations are primitive recursive:
\begin{enumerate}
\item $\fn{Fn}(x, n)$ iff $x$ is the code of $\Obj f^n_i$ for
  some~$i$, i.e., $x$ is the code of an $n$-ary !!{function}.
\item $\fn{Pred}(x, n)$ iff $x$ is the code of $\Obj P^n_i$ for
  some~$i$ or $x$ is the code of $\eq$ and $n = 2$, i.e., $x$ is the
  code of an $n$-ary !!{predicate}.
\end{enumerate}
\end{prop}

\begin{defn}
If $\tuple{s_0, \dots, s_n}$ is a sequence of symbols, its
\emph{G\"odel number} is $\tuple{\scode{s_0}, \dots, \scode{s_n}}$.
\end{defn}

\end{document}
