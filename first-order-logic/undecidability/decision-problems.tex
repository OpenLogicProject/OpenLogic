% Part: first-order-logic
% Chapter: undecidability
% Section: decision-problems

\documentclass[../../include/open-logic-section]{subfiles}

\begin{document}

\olfileid{fol}{und}{dec}
\olsection{Decision Problems}

\begin{explain}
We have a number of important logical notions, such as those of
satisfiability, validity, and consequence, which are properties of
(sets) !!{formula}s or relations between them.  The definitions of these
logical notions provide \emph{criteria} for when, say, a sentence is
valid. (In this case, it is valid iff it is satisfied in every first-order
!!{structure}.)  These criteria, however, do not in general provide a
\emph{method for deciding} if a sentence or set of sentences has the
property in question.  The question of whether there is such a method
for a given notion and class of !!{formula}s or sentences is called a
\emph{decision problem}.
\end{explain}

\begin{ex}
The \emph{decision problem for validity of sentences in a first-order
  language} is the question of whether there is a procedure for
deciding, given a sentence in a first-order language, if it is valid
or not.
\end{ex}

\begin{ex}
The \emph{decision problem for satisfiability of sentences in a first-order
  language} is the question of whether there is a procedure for
deciding, given a sentence in a first-order language, if it is satisfiable
or not.
\end{ex}

\begin{explain}
We say that a decision problem is \emph{solvable} if there is such a
procedure, and \emph{unsolvable} otherwise.  

To show that a decision problem is solvable, you typically simply
write down the procedure that solves it (and prove that it in fact
solves it correctly in every case).  Proving that a decision problem
is unsolvable is a lot harder: you have to show that there can
\emph{in principle} be no procedure whatsoever that solves it.  This
can only be done rigorously if there is a precise definition of what a
``procedure'' is.

One such precise definition is provided by the notion of a
\emph{Turing machine}.  A decision problem is solvable by a Turing
machine if there is a Turing machine which, when started on the
description of an instance of the decision problem as input,
eventually halts with simply ``1'' or ``0'' on the tape, representing
``yes'' or ``no'', respectively.  To show that a decision problem is
not solvable it suffices to show that no such Turing machine exists.

There are decision problems that can relatively easily be shown to be
unsolvable by Turing machines, such as the Halting problem.  To show
logical decision problems undecidable, you show that a known
unsolvable problem can be ``reduced'' to it.  A decision problem~A can
be reduced to a decision problem~B iff the answer to an instance of~A
can be obtained by an answer to an instance of~B.  For instance, the
problem of validity of a sentence can be reduced to that of
satisfiability: Given a sentence~$!A$, form the sentence~$\lnot !A$:
the former is valid iff the latter is not satisfiable. So the decision
problem for validity can be solved by taking an instance, transforming
that instance into its negation by putting ``$\lnot$'' in front of it,
obtaining the answer to ``Is $\lnot !A$ satisfiable?,'' and switching
the answer.  This shows that the problem of validity can be reduced to
the problem of satisfiability.

A reduction of a decision problem~A to a decision problem~B shows two things:
\begin{enumerate}
\item If B is solvable, then A is solvable.
\item If A is unsolvable, then B is unsolvable.
\end{enumerate}

A decision problem can therefore be shown to be unsolvable by reducing
a known unsolvable problem, such as the Halting Problem, to it.
\end{explain}

\end{document}
