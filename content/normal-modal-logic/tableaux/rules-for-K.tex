% Part: normal-modal-logic
% Chapter: tableaux
% Section: rules-for-K

\documentclass[../../../include/open-logic-section]{subfiles}

\begin{document}

\olfileid{nml}{tab}{rul}

\olsection{Rules for \Ax{K}}

The rules for the regular propositional connectives are the same as
for regular propositional signed !!{tableau}s, just with prefixes
added. In each case, the rule applied to a signed !!{formula}
$\sFmla{S}{!A}[\sigma]$ produces new !!{formula}s that are also
prefixed by~$\sigma$. This should be intuitively clear: e.g., if $!A
\land !B$ is true at (a world named by)~$\sigma$, then $!A$ and $!B$
are true at~$\sigma$ (and not at any other world). We collect the
propositional rules in \olref{tab:prop-rules}.

\begin{table}
  \[\def\arraystretch{3}\begin{array}{|c|c|}
    \hline
    \AxiomC{\sFmla{\True}{\lnot !A}[\sigma]}
    \RightLabel{\TRule{\True}{\lnot}}
    \UnaryInfC{\sFmla{\False}{!A}[\sigma]}
    \DisplayProof
    &
    \AxiomC{\sFmla{\False}{\lnot !A}[\sigma]}
    \RightLabel{\TRule{\False}{\lnot}}
    \UnaryInfC{\sFmla{\True}{!A}[\sigma]}
    \DisplayProof
    \\[1ex]
    \hline
    \AxiomC{\sFmla{\True}{!A \land !B}[\sigma]}
    \RightLabel{\TRule{\True}{\land}}
    \UnaryInfC{\sFmla{\True}{!A}[\sigma]}
    \noLine
    \UnaryInfC{\sFmla{\True}{!B}[\sigma]}
    \DisplayProof
    &
    \AxiomC{\sFmla{\False}{!A \land !B}[\sigma]}
    \RightLabel{\TRule{\False}{\land}}
    \UnaryInfC{$\sFmla{\False}{!A}[\sigma] \quad \mid \quad
      \sFmla{\False}{!B}[\sigma]$}
    \DisplayProof
    \\[2ex]
    \hline
    \AxiomC{\sFmla{\True}{!A \lor !B}[\sigma]}
    \RightLabel{\TRule{\True}{\lor}}
    \UnaryInfC{$\sFmla{\True}{!A}[\sigma] \quad \mid \quad
      \sFmla{\True}{!B}[\sigma]$}
    \DisplayProof
    &
    \AxiomC{\sFmla{\False}{!A \lor !B}[\sigma]}
    \RightLabel{\TRule{\False}{\lor}}
    \UnaryInfC{\sFmla{\False}{!A}[\sigma]}
    \noLine
    \UnaryInfC{\sFmla{\False}{!B}[\sigma]}
    \DisplayProof
    \\[2ex]
    \hline
    \AxiomC{\sFmla{\True}{!A \lif !B}[\sigma]}
    \RightLabel{\TRule{\True}{\lif}}
    \UnaryInfC{$\sFmla{\False}{!A}[\sigma] \quad \mid
      \quad \sFmla{\True}{!B}[\sigma]$}
    \DisplayProof
    &
    \AxiomC{\sFmla{\False}{!A \lif !B}[\sigma]}
    \RightLabel{\TRule{\False}{\lif}}
    \UnaryInfC{\sFmla{\True}{!A}[\sigma]}
    \noLine
    \UnaryInfC{\sFmla{\False}{!B}[\sigma]}
    \DisplayProof
    \\[2ex]
    \hline
  \end{array}\]
  \caption{Prefixed !!{tableau} rules for the propositional
    connectives}
  \ollabel{tab:prop-rules}
\end{table}

The closure condition is the same as for ordinary !!{tableau}s,
although we require that not just the !!{formula}s but also the
prefixes must match. So a branch is closed if it contains both
\[
\sFmla{\True}{!A}[\sigma] \quad\text{and}\quad \sFmla{\False}{!A}[\sigma]
\]
for some prefix $\sigma$ and !!{formula}~$!A$.

The rules for setting up assumptions is also as for ordinary
!!{tableau}s, except that for assumptions we always use the
prefix~$1$. (It does not matter which prefix we use, as long as it's
the same for all assumptions.) So, e.g., we say that
\[
!B_1, \dots, !B_n \Proves !A
\]
iff there is a closed tableau for the assumptions
\[
\sFmla{\True}{!B_1}[1], \dots, \sFmla{\True}{!B_n}[1],
\sFmla{\False}{!A}[1].
\]

For the modal operator\iftag{prvBox}{\iftag{prvDiamond}{s~$\Box$
    and}{~$\Box$}}{}\iftag{prvDiamond}{~$\Diamond$}{}, the prefix of
the conclusion of the rule applied to !!a{formula} with
prefix~$\sigma$ is $\sigma.n$. However, which $n$ is allowed depends
on whether the sign is~$\True$ or~$\False$.

\iftag{prvBox}{The $\TRule{\True}{\Box}$ rule extends a branch
  containing $\sFmla{\True}{\Box !A}[\sigma]$ by
  $\sFmla{\True}{!A}[\sigma.n]$.\iftag{prvDiamond}{ Similarly,
    t}{}}{T}\iftag{prvDiamond}{he $\TRule{\False}{\Diamond}$ rule
  extends a branch containing $\sFmla{\False}{\Diamond !A}[\sigma]$ by
  $\sFmla{\False}{!A}[\sigma.n]$.}{}
\iftag{notprvBox,notprvDiamond}{It}{They} can only be applied for a
prefix~$\sigma.n$ which \emph{already} occurs on the branch in which
it is applied. Let's call such a prefix ``used'' (on the branch).

\iftag{prvBox}{The $\TRule{\False}{\Box}$ rule extends a branch
  containing $\sFmla{\False}{\Box !A}[\sigma]$ by
  $\sFmla{\False}{!A}[\sigma.n]$.\iftag{prvDiamond}{ Similarly,
    t}{}}{T}\iftag{prvDiamond}{he $\TRule{\True}{\Diamond}$ rule extends
  a branch containing $\sFmla{\True}{\Diamond !A}[\sigma]$ by
  $\sFmla{\True}{!A}[\sigma.n]$.}{}
\iftag{notprvBox,notprvDiamond}{This rule}{These rules}, however, can
only be applied for a prefix~$\sigma.n$ which \emph{does not} already
occur on the branch in which it is applied. We call such prefixes
``new'' (to the branch).

The rules are given in \olref{tab:rules-K}.

\begin{table}
  \begin{center}
    \def\arraystretch{3}\def\fCenter{}
    \begin{tabular}{|c|c|}
    \hline
    \iftag{prvBox}{
      \AxiomC{\sFmla{\True}{\Box !A}[\sigma]}
      \RightLabel{\TRule{\True}{\Box}}
      \UnaryInfC{\sFmla{\True}{!A}[\sigma.n]}
      \DisplayProof
      &
      \AxiomC{\sFmla{\False}{\Box !A}[\sigma]}
      \RightLabel{\TRule{\False}{\Box}}
      \UnaryInfC{\sFmla{\False}{!A}[\sigma.n]}
      \DisplayProof\\
      $\sigma.n$ is used & $\sigma.n$ is new
      \\[1ex]
      \hline}{}
    \iftag{prvDiamond}{
      \AxiomC{\sFmla{\True}{\Diamond !A}[\sigma]}
      \RightLabel{\TRule{\True}{\Diamond}}
      \UnaryInfC{\sFmla{\True}{!A}[\sigma.n]}
      \DisplayProof
      &
      \AxiomC{\sFmla{\False}{\Diamond !A}[\sigma]}
      \RightLabel{\TRule{\False}{\Diamond}}
      \UnaryInfC{\sFmla{\False}{!A}[\sigma.n]}
      \DisplayProof\\
      $\sigma.n$ is new & $\sigma.n$ is used
      \\[1ex]
      \hline}{}
    \end{tabular}
  \end{center}
  \caption{The modal rules for \Ax{K}.}
  \ollabel{tab:rules-K}
\end{table}

The requirement that the restriction that the prefix for
\iftag{prvBox}{\TRule{\True}{\Box}}{\TRule{\False}{\Diamond}} must be
used is necessary as otherwise we would count the following as a
closed !!{tableau}:
\iftag{notprvBox,notprvDiamond}{%
  \iftag{prvBox}{%
  \begin{oltableau}
    [\pFmla{\True}{\Box \formula{A}}{1}, just = \TAss
      [\pFmla{\False}{\lnot\Box\lnot \formula{A}}{1}, just = \TAss
        [\pFmla{\True}{\formula{A}}{1.1}, just = {\TRule{\True}{\Box}[1]}
          [\pFmla{\True}{\Box\lnot\formula{A}}{1},
            just ={\TRule{\False}{\lnot}[2]}
            [\pFmla{\True}{\lnot\formula{A}}{1.1},
              just = {\TRule{\True}{\Box}[4]}
              [\pFmla{\False}{\formula{A}}{1.1},
                  just ={\TRule{\True}{\lnot}[5]}, close]
            ]
          ]
        ]
      ]
    ]
  \end{oltableau}
  }{
  \begin{oltableau}
    [\pFmla{\True}{\lnot\Diamond\lnot \formula{A}}{1}, just = \TAss
      [\pFmla{\False}{\Diamond\formula{A}}{1}, just = \TAss
        [\pFmla{\False}{\formula{A}}{1.1}, just = {\TRule{\False}{\Diamond}[2]}
          [\pFmla{\False}{\Diamond\lnot\formula{A}}{1},
            just ={\TRule{\True}{\lnot}[1]}
            [\pFmla{\False}{\lnot\formula{A}}{1.1},
              just = {\TRule{\False}{\Diamond}[4]}
              [\pFmla{\True}{\formula{A}}{1.1},
                  just ={\TRule{\True}{\lnot}[5]}, close]
            ]
          ]
        ]
      ]
    ]
  \end{oltableau}
}}{
  \begin{oltableau}
    [\pFmla{\True}{\Box \formula{A}}{1}, just = \TAss
      [\pFmla{\False}{\Diamond \formula{A}}{1}, just = \TAss
        [\pFmla{\True}{\formula{A}}{1.1}, just = {\TRule{\True}{\Box}[1]}
          [\pFmla{\False}{\formula{A}}{1.1},
            just = {\TRule{\False}{\Diamond}[2]}, close]
        ]
      ]
    ]
\end{oltableau}}

But $\Box \formula{A} \Entails/ \Diamond \formula{A}$, so our proof
system would be unsound. Likewise, $\Diamond \formula{A} \Entails/
\Box \formula{A}$, but without the restriction that the prefix for
\iftag{prvBox}{\TRule{\False}{\Box}}{\TRule{\True}{\Diamond}} must be
new, this would be a closed tableau: \iftag{notprvBox,notprvDiamond}{%
  \iftag{prvBox}{%
  \begin{oltableau}
    [\pFmla{\True}{\lnot\Box\lnot \formula{A}}{1}, just = \TAss
      [\pFmla{\False}{\Box \formula{A}}{1}, just = \TAss
        [\pFmla{\False}{\formula{A}}{1.1}, just = {\TRule{\True}{\Box}[2]}
          [\pFmla{\False}{\Box\lnot\formula{A}}{1},
            just ={\TRule{\True}{\lnot}[1]}
            [\pFmla{\False}{\lnot\formula{A}}{1.1},
              just = {\TRule{\False}{\Box}[4]}
              [\pFmla{\True}{\formula{A}}{1.1},
                  just ={\TRule{\False}{\lnot}[5]}, close]
            ]
          ]
        ]
      ]
    ]
  \end{oltableau}
  }{
  \begin{oltableau}
    [\pFmla{\True}{\Diamond \formula{A}}{1}, just = \TAss
      [\pFmla{\False}{\lnot\Diamond\lnot\formula{A}}{1}, just = \TAss
        [\pFmla{\True}{\formula{A}}{1.1}, just = {\TRule{\True}{\Diamond}[1]}
          [\pFmla{\True}{\Diamond\lnot\formula{A}}{1},
            just ={\TRule{\False}{\lnot}[2]}
            [\pFmla{\True}{\lnot\formula{A}}{1.1},
              just = {\TRule{\True}{\Diamond}[4]}
              [\pFmla{\False}{\formula{A}}{1.1},
                  just ={\TRule{\True}{\lnot}[5]}, close]
            ]
          ]
        ]
      ]
    ]
  \end{oltableau}
}}{
  \begin{oltableau}
    [\pFmla{\True}{\Diamond \formula{A}}{1}, just = \TAss,name=one
      [\pFmla{\False}{\Box \formula{A}}{1}, just = \TAss, name=two
        [\pFmla{\True}{\formula{A}}{1.1}, just = {\TRule{\True}{\Diamond}[1]}
          [\pFmla{\False}{\formula{A}}{1.1},
            just = {\TRule{\False}{\Box}[2]}, close]
        ]
      ]
    ]
  \end{oltableau}}

\end{document}
