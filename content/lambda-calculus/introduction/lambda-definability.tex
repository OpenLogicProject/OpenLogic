% Part: lambda-calculus
% Chapter: introduction
% Section: lambda-definability

\documentclass[../../../include/open-logic-section]{subfiles}

\begin{document}

\olfileid{lam}{int}{rep}
\olsection{\usetoken{S}{lambda definable} Arithmetical Functions}

How can the lambda calculus serve as a model of computation? At first,
it is not even clear how to make sense of this statement. To talk
about computability on the natural numbers, we need to find a suitable
representation for such numbers. Here is one that works surprisingly
well.

\begin{defn}
For each natural number~$n$, define the \emph{Church numeral}
$\num{n}$ to be the lambda term $\lambd[x][\lambd[y][(x(x(x(\dots
x(y)))))]]$, where there are $n$ $x$'s in all.
\end{defn}

The terms $\num{n}$ are ``iterators'': on input $f$, $\num{n}$ returns
the function mapping $y$ to $f^n(y)$. Note that each numeral is
normal. We can now say what it means for a lambda term to ``compute''
a function on the natural numbers.

\begin{defn}
Let $f(x_0, \dots, x_{k-1})$ be an $n$-ary partial function from $\Nat$
to $\Nat$. We say a $\lambd$-term~$F$ \emph{!!{lambda define}s}~$f$ iff for every
sequence of natural numbers $n_0$, \dots,~$n_{k-1}$,
\[
F\, \num{n_0}\, \num{n_1} \dots \num{n_{k-1}} \red \num{f(n_0, n_1, \dots,
  n_{k-1})}
\]
if $f(n_0, \dots, n_{k-1})$ is defined, and $F, \num{n_0}\, \num{n_1}
\dots \num{n_{k-1}}$ has no normal form otherwise.
\end{defn}

\begin{thm}
\ollabel{thm:lambda-def}
A function $f$ is a partial computable function if and only if it is
!!{lambda defined} by a lambda term.
\end{thm}

\begin{explain}
This theorem is somewhat striking. As a model of computation, the
lambda calculus is a rather simple calculus; the only operations are
lambda abstraction and application!{} From these meager resources,
however, it is possible to implement any computational procedure.
\end{explain}

\end{document}
