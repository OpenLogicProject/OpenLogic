% Part: lambda-calculus
% Chapter: introduction
% Section: lambda-computable

\documentclass[../../../include/open-logic-section]{subfiles}

\begin{document}

\olfileid{lam}{int}{cmp}
\olsection{\usetoken{S}{lambda definable} Functions are Computable}

\begin{thm}
\ollabel{thm:lambda-computable}
If a partial function $f$ is !!{lambda defined} by a lambda term, it is
computable.
\end{thm}

\begin{proof}
Suppose a function~$f$ is !!{lambda defined} by a lambda term~$X$. Let us
describe an informal procedure to compute~$f$. On input $m_0$,
\dots,~$m_{n-1}$, write down the term $X \num m_0 \ldots \num
m_{n-1}$. Build a tree, first writing down all the one-step reductions
of the original term; below that, write all the one-step reductions of
those (i.e., the two-step reductions of the original term); and keep
going. If you ever reach a numeral, return that as the answer;
otherwise, the function is undefined.

An appeal to Church's thesis tells us that this function is
computable. A better way to prove the theorem would be to give a
recursive description of this search procedure. For example, one
could define a sequence primitive recursive functions and relations,
``$\fn{IsASubterm}$,'' ``$\fn{Substitute}$,''
``$\fn{ReducesToInOneStep}$,'' ``$\fn{ReductionSequence}$,''
``$\fn{Numeral}$,'' etc. The partial recursive procedure for computing
$f(m_0, \dots, m_{n-1})$ is then to search for a sequence of one-step
reductions starting with $X \num{m_0} \dots \num{m_{n-1}}$ and ending
with a numeral, and return the number corresponding to that numeral.
The details are long and tedious but otherwise routine.
\end{proof}

\end{document}
