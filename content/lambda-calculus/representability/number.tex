% Part: lambda-calculus
% Chapter: representability
% Section: number

\documentclass[../../../include/open-logic-section]{subfiles}

\begin{document}

\olfileid{lc}{rep}{num}
\olsection{Number}

We can also encode natural numbers in lambda calculus. Let
$\num{n}$ be the term for the number $n$, which is defined as:
\begin{align*}
  \num{n} &\eqs \lambd[fx][f^n(x)]
\end{align*}
where $f^n(x)$ stands for $x$ applied by $f$ for $n$ times. For
example, $\num{3}$ is defined to be $f(f(f(x)))$. 

As we can see, the natural number $n$ is encoded as a function
accepting two arguments $f$ and $x$, returning $f^n(x)$. This encoding
of natural numbers is called \emph{church numeral}, invented by Alonzo
Church.

In the rest of the chapter there will be terms involving church
numerals, which will be written in the form of $n$ instead of
$\num{n}$ for simplicity. In the explanation of such terms, there will
also be $n$, which stands for the actual number the church numeral in
the term represents.


We first define the predicate $iszero$, which accepts a number and
returns a boolean depending on if the number is zero:
\begin{align*}
  iszero &\eqs \lambd[n][n (\lambd[x][false]) true]
\end{align*}
How does it work? As church numerals are defined as iterators (of $n$
times), we set the initial value to be $true$, and for every step of
iteration, we return $false$ whatever the result of last iteration is.
This step will be applied on the initial value for $n$ times, and the
result will be $true$ if and only if the step is not applied at all,
meaning $n$ is zero.

Successor is defined to be
\begin{align*}
  {succ} &= \lambd[{n}][\lambd[fx][f ({n} f x)]]
\end{align*}

To understand this: we first accept as argument a number ${n}$, and we want to return another number,
which should be a function that accepts
two arguments $f$ and $x$, and returns $f^{n+1}(x)$
which is done by first using ${n}$ to get $f^n(x)$, and then applying $f$ once more.

There's another definition of successor:
\begin{align*}
  {succ} &\eqs \lambd[{n}][\lambd[fx][{n} f (f x)]]
\end{align*}

\begin{prob}
  Explain why this successor also works, as we did for the first successor.
\end{prob}

Now we define the addition function:
\begin{align*}
  {add} &\eqs \lambd[{a}{b}][\lambd[fx][{a} f ({b} f x)]]
\end{align*}
or alternatively:
\begin{align*}
  {add} &\eqs \lambd[{a}{b}][{a} ~ {succ} ~ {b}]
\end{align*}

The first addition works as follows: we first accept two numbers ${a}$ and
${b}$, and want to return another number, which is a function that accepts
$f$ and $x$ and returns $f^{a+b}(x)$, which is equal to
$f^{a}(f^{b}(x))$, which is exactly what we are doing.

The second addition is simpler, as $succ^a(b)$ is equal to ${a + b}$.

And the multiplication:
\begin{align*}
  {mult} &\eqs \lambd[{a}{b}][\lambd[fx][{a} ({b} f) x]]
\end{align*}

Note what we get by ${b} f$: it is a function applying $f$
to the argument for $b$ times. Thus what we are doing by ${a} ({b} f) x$ is applying ``applying
$f$ for $b$ times'' for $a$ times to $x$, which is applying $f$ for $a
\times b$ times to $x$. We can actually simplify this term further by
$\eta$-reduction:
\begin{align*}
  {mult} &\eqs \lambd[ab][\lambd[f][a (b f)]]
\end{align*}

We can also make it by $add$:
\begin{align*}
  {mult} &\eqs \lambd[ab][a (add ~ a) 0]
\end{align*}

\begin{prob}
  Explain why this definition also work.
\end{prob}

We can even calculate exponentiation in lambda calculus, and it is
(surprisingly) rather simple:
\begin{align*}
  {pow} &\eqs \lambd[be][e b]
\end{align*}
where $b$ stands for base and $e$ stand for exponent. 
This definition is kind of magical and hard to explain, but
intuitively $e f$ is $f^e$ by our encoding of numbers. If you find it
hard to understand, we can still define it by multiplication:
\begin{align*}
  {pow} &\eqs \lambd[be][e ({mult}~ b) 1]
\end{align*}

Predecessor and subtraction on church numeral is not that simple as we might think: it
requires encoding of pairs which is introduced in the next section,
at the end of which we define both.
\end{document}