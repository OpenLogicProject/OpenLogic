% Part: lambda-calculus
% Chapter: representability
% Section: fixpoint

\documentclass[../../../include/open-logic-section]{subfiles}

\begin{document}

\olfileid{lc}{rep}{fp}

\olsection{Fixpoint}

Now we're able to represent natural numbers, pairs and
lists by terms, we can do lots of fun stuff; for instance we can
define the factorial function:
\begin{align*}
  fac &\eqs \lambd[n][iszero ~ n ~ 0 ~ (mult ~ n (fac (pred ~ n)))]
\end{align*}
All the referenced functions are defined in previous sections.
Recall that $iszero n$ returns a boolean, which is a function
selecting between the two arguments based on the represented boolean.
Thus it will select $0$ if $iszero ~ n$ is yes, and $(mult ~ n (fac
(pred ~ n)))$ otherwise. This is exactly the definition we see on any
textbook.

However this definition is problematic: why can we use $fac$ in the
definition of $fac$? Note that recursive definition (self-reference)
is not part of lambda calculus. When we write definition of $true$,
$false$, numbers and functions, for example:
\begin{align*}
    {mult} &\eqs \lambd[ab][a (add ~ a) 0]
\end{align*}
, we can always plug the definition of $add$ in the place of the
reference of $add$ in $mult$, and do it recursively if there are still
references in $add$ definition, until we have a reference-free $mult$ definition, which
is a pure lambda term, meaning this is indeed something in lambda calculus.

However this is not true in the case of self-reference; if we plug the
definition of $fac$ itself in the place of $fac$ in the right hand, we
get:
\begin{align*}
  fac &\eqs \lambd[n][iszero ~ n ~ 0 ~ (mult ~ n ((\lambd[n][iszero ~ n ~
  0 ~ (mult ~ n (fac (pred ~ n)))]) (pred ~ n)))]
\end{align*}
and we still haven't gotten rid of the reference. We can do this again
and again and the definition can keep growing. Thus this way of
defining factorial (or more generally self-reference functions) is not
feasible.

However, if someone could give us the function being defined, that
would be great. That is, we can define factorial as follows:
\begin{align*}
  fac' &\eqs \lambd[f][\lambd[n][iszero ~ n ~ 0 ~ (mult n (f (pred n)))]]
\end{align*}
and expect someone will pass the real factorial as parameter $f$ to $fac'$, then
the returning function is another factorial. Moreover, the factorial
being passed and the factorial being returns should be same.

That is, if we regard $fac'$ as a function accepting a function and
returning a function, then the fixpoint of $fac'$ would be the
factorial. So now we are looking for some technique to compute the
fixpoint of a term. And indeed there are some terms doing such things,
among which the best-known is the \emph{Y-combinator}, which is
defined as follows:
\begin{align*}
  Y &\eqs  \lambd[f][(\lambd[x][f (x x)]) (\lambd[x][f (x x)])]
\end{align*}
, which has the fancy property that:
\begin{align*}
  Y g &= \lambd[f][(\lambd[x][f (x x)]) (\lambd[x][f (x x)])] g \\
      &= (\lambd[x][g (x x)]) (\lambd[x][g (x x)]) \\
      &= g ((\lambd[x][g (x x)]) (\lambd[x][g (x x)])) \\
      &= g (Y g)
\end{align*}
for any term $g$. We can extend this term as many times as we want,
and we will get:
\begin{align*}
    Y g &= g (Y g) \\
        &= g (g (Y g)) \\
        &\ldots \\
        &= g (g (\ldots ))
\end{align*}
Note how the last term is analogous to fixed-point iteration, a method used to
compute the fixpoint of a real-valued function. Thus intuitively
speaking $g$ applied on any term for infinite times should be a
fixpoint of $g$. To get a concrete feeling, we can try out some terms;
take the factorial for instance:
\begin{align*}
  fac &\eqs Y ~ fac'\\
  fac 3 &= Y ~ fac' ~ 3 \\
      &=fac' (Y ~ fac') 3 \\
      &=(\lambd[f][\lambd[n][iszero ~ n ~ 0 ~ (mult ~ n (f (pred ~ n)))]])
  fac ~ 3\\
      &= mult ~ 3 ~ (fac ~ 2) \\
      \ldots
\end{align*}

\begin{prob}
  Finish the above equation to the result of $6$.
\end{prob}

\end{document}

