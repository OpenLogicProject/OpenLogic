% Part: computability
% Chapter: computability-theory
% Section: normal-form

\documentclass[../../../include/open-logic-section]{subfiles}

\begin{document}

\olfileid{cmp}{thy}{nfm}
\olsection{The Normal Form Theorem}

Suppose we can describe definitions of computable functions, and test if
some putative description of the complete record of the computation of
that function on some input is correct. Then it stands to reason that
independently of the model of computation, we can determine the value
of any computable function~$f$ on any input~$x$ as follows:
\begin{enumerate}
  \item Search through all possible descriptions of records of
  computation.
  \item Test if a given record is the record of a computation of~$f(x)$.
  \item Extract the value of~$f(x)$ from the correct record if we have
  found it.
\end{enumerate}
That this is in fact true is the content of Kleene's normal form
theorem.

\begin{thm}[Kleene's Normal Form Theorem]
\ollabel{thm:normal-form}
There are a primitive recursive relation~$T(e, x, s)$ and a primitive
recursive function~$U(s)$, with the following property: if $f$ is any
partial computable function, then for some~$e$,
\[
f(x) \simeq U(\umin{s}{T(e, x, s)})
\]
for every~$x$.
\end{thm}

\begin{proof}[Proof Sketch]
For any model of computation one can rigorously define a description
of the computable function~$f$ and code such description using a
natural number~$e$.  One can also rigorously define a notion of
``computation sequence'' which records the process of computing the
function with index~$e$ for input~$x$.  Such a computation sequence can
likewise be coded as a number~$s$.  This can be done in such a way
that
\begin{enumerate}
  \item the relation $T(e, x, s)$, which holds iff a number~$s$ codes the computation
  sequence of the function with index~$e$ on input~$x$, and
  \item the function $U(s)$ which maps a computation sequence coded
  by~$s$ to the end result of that computation
\end{enumerate}
are both computable. In fact, the relation~$T$ and the function~$U$
are primitive recursive.
\end{proof}

\begin{explain}
In order to give a rigorous proof of the Normal Form Theorem, we would
have to fix a model of computation and carry out the coding of
descriptions of computable functions and of computation sequences in
detail, and verify that the relation~$T$ and function~$U$ are
primitive recursive.  For most applications, it suffices that $T$
and~$U$ are computable and that $U$~is total.

It is probably best to remember the proof of the normal form theorem
in slogan form: $\umin{s}{T(e, x, s)}$ searches for a computation
sequence of the function with index~$e$ on input~$x$, and $U$ returns
the output of the computation sequence if one can be found.
\end{explain}

If the model of computation is the partial recursive functions (which
is what Kleene originally used), it shows that only a single use of
unbounded search, i.e., a single $\umin{y}{f(\vec x, y)}$ operator is
necessary for the definition of any function. In this sense it shows
that any partial recursive function has a normal form.

$T$ and $U$ can be used to define the enumeration $\cfind{0}$,
$\cfind{1}$, $\cfind{2}$, \dots.  From now on, we will assume that we
have fixed a suitable choice of $T$ and~$U$, and take the equation
\[
\cfind{e}(x) \simeq U(\umin{s}{T(e,x,s)})
\]
to be the \emph{definition} of $\cfind{e}$.

Here is another useful fact:

\begin{thm}
Every partial computable function has infinitely many indices.
\end{thm}

Again, this is intuitively clear.  Given any (description of) a
computable function, one can come up with a different description
which computes the same function (input-output pair) but does so,
e.g., by first doing something that has no effect on the computation
(say, test if $0 = 0$, or count to $5$, etc.).  The index of the
altered description will always be different from the original
index.  Both are indices of the same function, just computed slightly
differently.

\end{document}
